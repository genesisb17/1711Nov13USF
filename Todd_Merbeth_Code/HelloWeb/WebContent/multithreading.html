<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Multithreading</title>

<link rel="stylesheet"
	href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css"
	integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb"
	crossorigin="anonymous">

<link rel="stylesheet" src="style.css" />
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
	integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
	crossorigin="anonymous"></script>
<script
	src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js"
	integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh"
	crossorigin="anonymous"></script>
<script
	src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js"
	integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ"
	crossorigin="anonymous"></script>
</head>
<style>
h1 {
padding-top: 12px;
font-size: 200%;
}
h2 {
	text-align: center;
	padding-bottom: 20px;
	padding-top:20px;
	font-weight: bold;
	text-decoration: underline;
	font-size:200%;
}

h4 {
	padding-top: 75px;
	font-weight: bold;
	font-size:150%;
	padding-bottom: 15px;
}
h5 {
	padding-top: 75px;
	font-weight: bold;
	font-size:110%;
	padding-bottom: 10px;
}

img {
	max-width: 50%;
	height: auto;
	display: block;
	padding: 0;
	margin: auto;
	margin-top: 50px;
	box-shadow: 0 0 30px black;
}

p {
	padding-left: 5px;
}
.container {
    max-width: 100vw;
}
</style>
<body
	style="background-color:#000033; line-spacing: 115%; font-size: 135%;">
	<header style="color:white; padding:8px 0 0 5vw; height:10vh;"><h1>Threads and Multithreading in Java</h1></header>
	<div class="container-fluid"
		style="height: 90vh; width: 100vw; margin-top: 0vh;">
		<div class="row" style="height: 100%;">
			<div class="col-2"
				style="padding: 0; margin: 0; border-radius: 25px 0px 0px 25px; height: 100%; font-family: Arial;">
				<div class="container bg-light"
					style="height: 100%; padding: 20% 0 0 0; margin: 0; border-radius: 0px 0px 0px 0px;">
					<nav id="navbar-example3"
						class="navbar navbar-light bg-light flex-column"
						style="border-radius: 25px 0px 0px 25px;">
						<nav class="nav nav-pills flex-column">
							<a class="nav-link active" href="#item-1">Threads</a>
							<nav class="nav nav-pills flex-column">
								<a class="nav-link ml-3 my-1" href="#item-1-1">What is a
									Thread?</a> <a class="nav-link ml-3 my-1" href="#item-1-2">Creation
									of a Thread</a> <a class="nav-link ml-3 my-1" href="#item-1-3">States
									of a Thread</a><a class="nav-link ml-3 my-1" href="#item-1-4">Lifecycle
									of a Thread</a>
							</nav>
							<hr> 
							<a class="nav-link" href="#item-2">Multithreading</a>
							<nav class="nav nav-pills flex-column">
								<a class="nav-link ml-3 my-1" href="#item-2-1">What is
									Multithreading?</a> <a class="nav-link ml-3 my-1" href="#item-2-2">Advantages
									of Multithreading</a> <a class="nav-link ml-3 my-1"
									href="#item-2-3">Issues of Multithreading</a>
							</nav>
						</nav>
					</nav>
				</div>
			</div>
			<div class="col-10" style="padding: 0; margin: 0; width: 100%;">
				<div class="container"
					style="height: 100%; width: 100%; padding: 25px 35px 25px 35px; font-family: Aerial; margin: 0; position: relative; overflow-y: scroll; background-color: #eee"
					data-spy="scroll" data-target="#navbar-example3" data-offset="25">
					<h2 id="item-1">Threads</h2>
					<h4 id="item-1-1">What is a Thread?</h4>
					<p>A Thread is an independent path of execution in a program.
						</p><br>
					<h4 id="item-1-2">Creation of a Thread</h4>
					<p>In order to create a thread a class must either:</p>
					<ol>
						<li>Implement the runnable interface</li>
						<li>Extend Thread class</li>
					</ol>
					<p>With either of these choices a run() method must be defined
						within the class. If you are extending the Thread class the run()
						method you define will be overriding the run() method from the
						parent class. This means you technically don't have to change the
						implementation, but it would be pointless not to do so as the
						run() method from the parent class doesn't actually do anything.</p>
					<br>
					<h4 id="item-1-3">States of a Thread</h4>
					<p>
						There are 6 possible states of a thread. These states are:<br>
					</p>
					<ol>
						<li>NEW - A new thread that has not started yet.</li>
						<li>RUNNABLE - When a thread is executing, or ready to
							execute at any moment.</li>
						<li>BLOCKED - When a thread is trying to access a protected
							section of code that's currently locked in some other thread.</li>
						<li>WAITING - When a thread is waiting indefinitely for
							another thread to perform a particular task. Must be notified by
							another thread to exit this state.</li>
						<li>TIMED_WAITING - When a thread is waiting a specified
							amount of time to allow another thread to complete something.</li>
						<li>TERMINATED - When a thread either finishes its thread of
							execution naturally, or because some unusual or exceptional event
							occurs such as a segmentation fault or an unhandled exception.</li>
					</ol>
					<p>Each thread can be in only one of these states at any given
						time.</p>
					<br>
					<h4 id="item-1-4">Lifecycle of a Thread</h4>
					<p>A thread first needs to be created. After creation a
						thread must call the start() method in order to begin its run()
						method. Once running a thread will attempt to complete its task.
						Threads can be blocked or told to wait if they need to access
						protected code in another thread that isn't ready to be accessed
						yet. This can be done with locks, sleeps, wait, and suspend
						methods. Depending on what call cause the thread to wait, it may
						or may not need to be notified by another thread to start again.
						When a thread finishes its task it terminates.</p><br>
					<img src="https://www.javatpoint.com/images/threadstates.jpg" style="border-radius:25%"><br><br>
					<hr> 
					<br>
					<h2 id="item-2">Multithreading</h2>
					<h4 id="item-2-1">What is Multithreading?</h4>
					<p>Multithreading is the process of executing multiple threads
						simultaneously. This can be done by computer systems using
						multiple CPUs, or having multi-core processors split up the work
						among the cores so that they can execute at the same time.</p>
					<br>
					<img src="https://www.javatpoint.com/images/multithreading.JPG"
						style="border-radius: 15%;" />
						<br>
						<br>
					<h4 id="item-2-2">Advantages of Multithreading</h4>
					<p>Multithreading has a number of advantages such as:</p>
					<ul>
						<li>Doesn't block the user because threads are independent</li>
						<li>Can perform many operations simultaneously to save time</li>
						<li>Threads won't break other threads if an exception occurs</li>
						<li>Threads are lightweight and share a the same address
							space</li>
						<li>Cost of communication between threads is low</li>
					</ul>
					<br>
					<h4 id="item-2-3">Issues of Multithreading</h4>
					<p>A number of issues can come up when using multiple threads.
						Two of the more common issues are deadlock and the
						producer-consumer problem.</p>
					<h5>Deadlock</h5>
					<p>Deadlock describes a situation where two or more threads are
						blocked forever, waiting for each other to finish. Deadlock occurs
						when multiple threads need the same locks but obtain them in
						different order. A multithreaded program may suffer from the
						deadlock condition because the synchronized keyword causes the
						executing thread to block while waiting for the lock, or monitor,
						associated with the specified object.</p>
					<p>There are a few solutions to this problem. One is to avoid
						using locks altogether by using lock-free data structures or
						copies of data structures. Another strategy is to avoid using
						nested locks and only allow one lock to be acquired at a time. If
						you must acquire multiple locks, always acquire them in the same
						order.</p>
					<h5>Producer-Consumer</h5>
					<p>The problem describes two processes, the producer and the
						consumer, which share a common, fixed-size buffer used as a queue.
						The producer's job is to generate data, put it into the buffer,
						and start again. The consumer is consuming the data (removing it
						from the buffer), one piece at a time at the same time. The
						problem arises when either the producer tries to add data into a
						full buffer, or the consumer tries to remove data from an empty
						buffer.</p>
					<p>The solution for this type of problem is for the producer to
						either go to sleep or discard data if the buffer is full. The next
						time the consumer removes an item from the buffer, it notifies the
						producer, who starts to fill the buffer again. In the same way,
						the consumer can go to sleep if it finds the buffer to be empty.
						The next time the producer puts data into the buffer, it wakes up
						the sleeping consumer.</p>
				</div>
			</div>
		</div>
	</div>
</body>
</html>