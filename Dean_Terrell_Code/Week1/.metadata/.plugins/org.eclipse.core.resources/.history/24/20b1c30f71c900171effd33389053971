import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.*;

public class SearchAndSorts {

	public static void main(String[] args) {

	int[] num = {5, 7, 3, 2, 8, 13, 12, 1, 0, 50, 32};
	
	if(BinarySearch(num, 13))
		System.out.println("13 was found!");
	else
		System.out.println("13 was not found.");
	
	int[] num2 = bubbleSort(num);
	
	System.out.printf("Original num: ");
	for(int i : num)
		System.out.printf(" %d", i);
	
	System.out.printf("Bubblesort num: ");
	
	for(int i : num2)
		System.out.printf(" %d", i);
	}
	
	static boolean BinarySearch(int[] data, int key) {
		int low = 0;
		int high = data.length - 1;
		
		while(high >= low) {
			int middle = (low + high) / 2;
			if(data[middle] == key) {
				return true;
			}
			if(data[middle] < key) {
				low = middle + 1;
			}
			if(data[middle] > key) {
				high = middle - 1;
			}
		}
		return false;
	}
	
    static int[] bubbleSort(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
            for (int j = 0; j < n-i-1; j++)
                if (arr[j] > arr[j+1])
                {
                    // swap temp and arr[i]
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
        return arr;
    }
    

	public static void mergeSort(Comparable [ ] a)
	{
		Comparable[] tmp = new Comparable[a.length];
		mergeSort(a, tmp,  0,  a.length - 1);
	}


	private static void mergeSort(Comparable [ ] a, Comparable [ ] tmp, int left, int right)
	{
		if( left < right )
		{
			int center = (left + right) / 2;
			mergeSort(a, tmp, left, center);
			mergeSort(a, tmp, center + 1, right);
			merge(a, tmp, left, center + 1, right);
		}
	}


    private static void merge(Comparable[ ] a, Comparable[ ] tmp, int left, int right, int rightEnd )
    {
        int leftEnd = right - 1;
        int k = left;
        int num = rightEnd - left + 1;

        while(left <= leftEnd && right <= rightEnd)
            if(a[left].compareTo(a[right]) <= 0)
                tmp[k++] = a[left++];
            else
                tmp[k++] = a[right++];

        while(left <= leftEnd)    // Copy rest of first half
            tmp[k++] = a[left++];

        while(right <= rightEnd)  // Copy rest of right half
            tmp[k++] = a[right++];

        // Copy tmp back
        for(int i = 0; i < num; i++, rightEnd--)
            a[rightEnd] = tmp[rightEnd];
    }
    
    public static int[] doInsertionSort(int[] input){
        
        int temp;
        for (int i = 1; i < input.length; i++) {
            for(int j = i ; j > 0 ; j--){
                if(input[j] < input[j-1]){
                    temp = input[j];
                    input[j] = input[j-1];
                    input[j-1] = temp;
                }
            }
        }
        return input;
    }
    
	public class Node {

	    private Node left;
	    private Node right;
	    private String label;

	    public Node(String label, Node left, Node right) {
	        this.left = left;
	        this.right = right;
	        this.label = label;
	    }

	    @Override
	    public String toString() {
	        return label;
	    }

	    public List<Node> getChildren() {
	        return Stream.of(left, right)
	               // .filter(Objects::nonNull)
	                .collect(Collectors.toList());
	    }
	    
	    public List<Node> searchByDepth() {
	        List<Node> visitedNodes = new LinkedList<>();
	        List<Node> unvisitedNodes = new LinkedList<>();
	        unvisitedNodes.add(this);

	        while(!unvisitedNodes.isEmpty()) {
	            Node currNode = unvisitedNodes.remove(0);

	            List<Node> newNodes = currNode.getChildren()
	                    .stream()
	                    .filter(node -> !visitedNodes.contains(node))
	                    .collect(Collectors.toList());

	            unvisitedNodes.addAll(0, newNodes);
	            visitedNodes.add(currNode);
	        }

	        return visitedNodes;
	    }
	    
	    public List<Node> searchByBreadth() {
	        List<Node> visitedNodes = new LinkedList<>();
	        List<Node> unvisitedNodes = Arrays.asList(this);

	        while(!unvisitedNodes.isEmpty()) {
	            List<Node> newNodes = unvisitedNodes
	                    .stream()
	                    .map(Node::getChildren)
	                    .flatMap(List::stream)
	                    .filter(node -> !visitedNodes.contains(node))
	                    .collect(Collectors.toList());

	            visitedNodes.addAll(unvisitedNodes);
	            unvisitedNodes = newNodes;
	        }

	        return visitedNodes;
	    }

	}

	}